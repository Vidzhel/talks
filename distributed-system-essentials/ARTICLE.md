# Дослідження та розв'язання проблем з індексами MongoDB. Специфіки Amazon Document DB

Так звана передчасна оптимізація (premature optimization) - трата часу на оптимізацію чогось несуттєвого, яка веде не
тільки до нечитабельного коду, а й до погіршення працездатності програми в цілому після зміни вимог.
Однак, коли виникає проблема, наприклад перша сторінка з 16 записів завантажується 40 секунд..., розумієш, що потрібно
зміна. Через те, що запит лише отримує документи з бази без ніякої додаткової логіки, вдалося швидко локалізувати
проблему, яка виявилася надто довгим запитом до Amazon Document DB.

Запит сам по собі не виглядає страшним. Той самий Entity Framework під час оптимізації видає ще те ще дерево запитів яке
можна довго обмізковувати.

![Problematic query](https://i.imgur.com/fYWkF3X.png)

## Дослідження проблеми

Коли маєш діло з такого роду проблемою, зразу виниш індекс, а тому потрібно переглянути як оптимізатор запитів виконує
його. Для цього в MongoDB
наявна [команда `explain()`](https://www.mongodb.com/docs/manual/reference/method/cursor.explain/), яка видає ієрархічне
зображення етапів виконання. Для того, щоб
отримати час виконання кожного етапу, потрібно передати `'executionStats'` як перший параметр. На відміну від DocDB,
монга також міє третій варіант команди, що повертає усі можливі плани, а не тільки обраний.

Скористуємося командою, щоб отримати більше інформації щодо запиту.

![Explain command usage](https://i.imgur.com/3ZE2omY.png)

![Explain command output](https://i.imgur.com/554u5Os.png)

Отриману ієрархію отриманого плану потрібно дивитися знизу вверх. Першим йде етап сканування чи вибірки за індексом. У
разі, якщо першим етапом був `COLLSCAN`, тоді проблема була б відразу зрозуміла, але в цьому випадку сканування індексу
зайняло ~40 секунд, отже потрібно копати далі. Обраний індекс під назвою `courseId_1` - індекс одного поля та не
покриває сортування за `lastActivity`.

Виконавши команду `db.collection.getIndexes()` перевіряємо наявні індекси та бачимо, що є більш оптимальний варіант
складного індексу `courseId_1_lastActivity_1_isArchived_1`, який чомусь не було обрано. Щоб розібратися чому, розглянемо
остовні критерії відносно яких оптимізатор запитів обирає індекс.

![Collection indexes list](https://i.imgur.com/j4vST9u.png)

- Для того, щоб розібратися більше, потрібно поговорити про самі індекси

### Критерії вибору індексу:

Причина чому деякі індекси не використовуються в окремих запитах банальна, вони просто не оптимальні, тому можуть тільки
сповільнити отримання результату.

- Індекс вказаний за допомогою команди `hint`. В цьому випадку просто обирається вказаний індекс, навіть якщо він не
  оптимальний.
- Індекс не схований. Для того, щоб протестувати швидкодію запитів без індексу (наприклад щоб замінити чи видалити його
  пізніше) не потрібно його видаляти, тому що відбудова займе багато часу, а можна сховати від планувальника запитів за
  допомогою команд `hideIndex` `unhideIndex`.
- Він в пам’яті. Потрібно слідкувати, щоб усі індекси поміщалися в оперативну пам'ять. Не забувайте про те, що крім
  індексів усіх колекцій, також виділяється пам'ять під операції. Для того, щоб дізнатися розмір індексів однієї
  колекції, потрібно виконати `db.courseResults.stats({ indexDetails: true, scale: 1000000000 })` (`scale` для зручності
  перегляду в Гб).
  ![Index usage stats](https://i.imgur.com/k7Xp0AP.png)
- Відповідність
  правилу **[ESR (Equality, Sort, Range)](https://www.mongodb.com/docs/manual/tutorial/equality-sort-range-rule/)**.
  Це правило вказує на необхідний порядку полів в складному індексі прий його створені. Спочатку йдуть поля, які в
  запитах фільтруються за допомогою операторів повного збігу, наприклад `$eq` (`$ne` - оператор діапазону, тому не
  підходить), далі йдуть поля за якими відбувається сортування (при чому сортування повинно відповідати сортуванню
  індексу в прямому або оберненому порядку, дивись наступний пункт), останніми йдуть оператори діапазону `$gt`, `$gte`
  , `$lt`, `$lte`, `$ne`. Цей порядок важливий, тому що у разі, коли ми захочемо використати оператор діапазону, а після
  цього відсортувати, серверу потрібно буде до-сортувати отримані результати в пам'яті, адже друге поле в індексі
  відсортоване відсортовано першого (знаю, звучить дуже заплутано, далі йде приклад). Наприклад, використовуємо оператор
  діапазону та отримуємо користувачів (дивись рисунок знизу) з id `ca2` та `xyz`, далі сортуємо по оцінці, але виходить
  що для користувача `xyz` запис з балом 90 повинен йти перед записом користувача `ca2` з оцінкою 75, отже не вистачає
  просто взяти документи за індексом, потрібно також виконувати дороге сортування в пам'яті. У випадку коли ми
  робимо `skip`, `limit`, проблема може з'являтися на сотій сторінці.

![Compound index visualization](https://i.imgur.com/qTr0faY.png)

- Правильний порядок сортування полів індексу. При створенні індексу, окрім полів, ми також вказуємо напрямок сортування
  за цим полем. Цей напрямок повинен дорівнювати або бути оберненим до того що вказано в запиті.

![Compound index and sorting rule](https://i.imgur.com/MmtfoK2.png)

- Але не потрібно забувати з якою звірюкою ми маємо діло, тому потрібно брати їх до уваги.

![Doc db is emulation of MongoDB](https://i.imgur.com/nrS2Uj9.png)

### Специфіки Doc DB

- Відсутність можливості сховати індекс від планера запиту
- Підтримка роботи операторів з індексами. При використанні зі складним індексом, скоріш за все буде виконуватися prefix
  індексу (про це далі)

![Usage of indexes with range operators unsupported](https://i.imgur.com/nrcmGWx.png)

## Розв'язання проблеми

Крім того, що проблемний запит має оператор діапазону `$ne`, як виявилося пізніше назва індексу не відповідає порядку
полів, тобто порушена відповідність правилу **ESR (Equality, Sort, Range)**. Це дуже підступна проблема, адже збиває з
пантелику, яку до того ж неможливо виправити не перестворюючи індекс (що не є дешевою операцією, особливо в DocDB). Тому
краще ніколи не давати ім'я індексу, таким чином воно буде створено автоматично.

![Wrong index name](https://i.imgur.com/RhUorDv.png)

Фактично, якби порядок полів відповідав назві індекс, то запит підпадав під правило prefix (бо, оператори
діапазону в DocDB ніколи не використовують індекс). Складні індекси можуть перевикористовуватися в запитах, які
використовують частину цього індекс (index prefix). Але в цьому випадку, немає ніякого сенсу триматися за оператор `$ne`
для булевого поля. Простіше мігрувати базу (створити відсутнє поле), та використовувати оператор `$eq` (не потрібно буде
навіть перестворювати індекс, хоча шляпа з назвою так і залишиться).

![Index prefix rule 1](https://i.imgur.com/N0ceA81.png)

![Index prefix rule 2](https://i.imgur.com/OCxreJj.png)

![Index prefix rule 3](https://i.imgur.com/TC1B6Pu.png)

Після виправлення умови запиту таким чином, щоб використовувати оператор рівності для поля `isArchived`, та встановлення
значення для поля `isArhived` документів, в який це поле відсутнє, індекс почав відповідати правилу ESR, тому саме він
був обраний для запиту, як видно з іншого запиту `explain()`

![Fixed query](https://i.imgur.com/RhQ6M6w.jpg)

![Fixed query execution stats](https://i.imgur.com/ussFx1e.jpg)

Далі йде невеличкий теоретичний блок про індекси, варіації, підтримку та чекліст по їх створенню.

## Індекси

В більшості випадків, коли розмовляємо про індекси, ми робимо це абстрактно, без вказування на те як він побудований.
Насправді в більшості випадків це просте дерево (btree). Приклад індексу з MS SQL:
![Index structure](https://docs.microsoft.com/en-us/sql/relational-databases/media/bokind2.gif)

Монга підтримує наступні типи індексів:

- Простий індекс `single field`
- Складний індекс `compound`
- Hashed. В більшості випадків може бути використано для шардінга за допомогою послідовного хешування. Знаючи значення
  поля, наприклад айдішнік юзера, можна порахувати хеш та подивитися, що значення хеша попадає в межі третього сервера
  бази даних, який і зберігає документ користувача. Це є один з варіантів масштабування за яким ми ділимо одну велику
  колекцію на різні сервера бази (не працює в DocDB, інша методика - primary/secondary реплікація).
- Індекси гео запитів `2dsphere`, `2d`. Корисні для пошуку в певному радіусі...
- Text, wildcard, regex - спрощена версія Elasticsearch, яка дозволяє обробити текст необхідної мови, прибравши стоп
  слова (the, a, an), обрізавши слово до кореня (stemming), вказати роздільник. Але, Elastic все ж гнучкіший, адже
  дозволяє налаштовувати конвеєр обробки тексту під себе, та має інші методи обробки тексту, наприклад додавання
  синонімів (2 - “two”)

### Модифікації індексів

- TTL - видаляє запис після спливання часу. Точність не гарантована. Потрібно зменшувати кількість записів що повинна
  бути видалена. Тобто якщо у нас це лог, в який кожну секунду потрапляють записи, які нам потрібно видалити через 7
  днів
  після створення, потрібно робити групування, наприклад в бакети погодинно або подобово та створювати індекс для них. В
  іншому випадку під час видалення буде досить сильне навантаження. Amazon також рекомендує групувати записи в колекції
  та видаляти їх повністю, бо це не навантажує систему (IO cost), що збільшує ціну, на відміну від того, коли нам
  кожну хвилину потрібно видаляти купу логів. Монга також каже використовувати Time series колекцій, що по суті також
  групують записи в бакети по часу.
- Unique - забороняє повтори
- Partial, Sparse (конкретна версія partial індексу) - якщо для більшості запитів не потрібно повертати якусь частину
  колекції (наприклад заархівовані записи), ми можемо використати partial індекс та вказати умову, за якої документ буде
  індексуватися. Це може стати в пригоді, коли потрібно створити unique індекс, але не всі документи мають унікальне
  поле (наприклад в деяких воно відсутнє, що також вважається за дуплікацію). Таким чином можна створити два індексу для
  різних типів запитів. Sparse - індексує тільки ті документи,
  які мають індексоване поле, цього можна досягти вказавши відповідну умову при створенні часткового індексу. (Індекси
  не підтримуються в DocDB).
- Індексування масивів (multikey index) - індексується кожен елемент/документ масиву. Після цього ми можемо шукати
  документи, які мають потрібні нам документи у внутрішньому масиві (наявна можливість вказувати декількох умов до
  одного й того ж елементу масиву за
  допомогою [оператора `$elemMatch`](https://www.mongodb.com/docs/manual/reference/operator/query/elemMatch/), який не
  підтримує індекс в DocDB).

### Специфіки Doc DB

Підтримка індексів

![Document DB and indexes support](https://i.imgur.com/SCbaYEw.png)

## Чекліст по створенню індексу:

- Потрібно створювати індекси, що
  мають [високу вибірковість](https://www.mongodb.com/docs/manual/core/query-optimization/#query-selectivity). Тобто не
  на полях з декількома можливими значеннями, як, наприклад boolean, або на тих полях, для яких використовуються
  оператори діапазону `$gt`, `$gte`, `$lt`, `$lte`.
- Перевірити відповідність складних індексів
  правилу [ESR](https://www.mongodb.com/docs/manual/tutorial/equality-sort-range-rule/).
- Якщо запит отримує тільки поля документа, що знаходяться в індексі (зазвичай складному), то не буде виконуватися
  операція отримання самого документа, дані будуть повернуті напряму з
  індексу ([covered queries](https://www.mongodb.com/docs/manual/core/query-optimization/#covered-query)).
- Індекс - відсортована структура. Тобто створення індексу (в тому числі складного з правильним напрямком сортування для
  кожного поля) пришвидшує запити з операцією сортування.
- При створенні складних індексів, краще не давати йому ім’я, в такому випадку ім’я буде згенеровано автоматично і
  відповідатиме порядку полів та напрямку сортування. Тому ім’я не буде вводити в оману. Ім’я неможливо буде змінити,
  без
  видалення індексу.
- Краще перевикористовувати індекси, бо вони займають багато місця та повинні поміщатися в оперативну пам'ять, а
  також тому що індекси збільшують час створення та оновлення документів.
  - `db.collection.aggregate([{$indexStats:{}}]).pretty()` - для перегляду статистики використання індексів

      ```javascript
      { name: 'attemptId_1',
        key: { attemptId: 1 },
        host: '...',,
        accesses: { ops: 323, since: 2022-05-08T02:25:57.000Z } }
      { name: 'courseId_1_lastActivity_1_isArchived_1',
        key: { courseId: 1, isArchived: 1, lastActivity: 1 },
        host: '...',,
        accesses: { ops: 272, since: 2022-05-08T02:25:57.000Z } }
      { name: 'actorEmail_1',
        key: { actorEmail: 1 },
        host: '...',
        accesses: { ops: 168177, since: 2022-05-08T02:25:57.000Z } }
      { name: 'courseId_1',
        key: { courseId: 1 },
        host: '...',
        accesses: { ops: 19503, since: 2022-05-08T02:25:57.000Z } }
      { name: '_id_',
        key: { _id: 1 },
        host: '...',
        accesses: { ops: 411342, since: 2022-05-08T02:25:57.000Z } }
      ```

- Якщо запити не мають наміру шукати по всіх документах колекції, наприклад у яких немає певного поля чи які були
  заархівовані створенням boolean поля, то рекомендується використання partial, sparse індексів,
  які не індексують всю колекцію (не працює в doc db), тому зменшують розмір індексу, а також час модифікації
  не індексованих записів.
- Щоб контролювати прогрес побудови індексу, потрібно виконати
  команду `db.currentOp(true).inprog.forEach(function(op){ if(op.msg!==undefined) print(op.msg) })` (MongoDB). Щоб
  зупинити побудову, потрібно виконати команду `dropIndex()`.
- Є два способи побудови індексу, foreground версія та background. В той час коли перша отримує lock на всю колекцію,
  друга дозволяє працювати з нею під час побудови, хоч це і повільніше. В останніх версіях монги, ці способи об’єднали,
  тому колекція блокується в початку і в кінці побудови, а під час роботи з колекцією можна працювати як завжди.
- Під час побудови індексу використовується диск, тому потрібно слідкувати, щоб вистачало місця. Також для пришвидшення
  операції рекомендується заскейлити екземпляр бази на час побудови індексу.

### Специфіки DocDB

- Побудова не почнеться доки не будуть завершені усі запити, що були запущені до початку побудови.
- Якщо відбувається побудова background індексу, в Doc DB, не можна розпочинати побудову нового, або видалення іншого в
  тій же колекції, тому що побудова зупиниться з помилкою.

![Document DB concurrent index maintenance operations warning](https://i.imgur.com/OQPh6HL.png)

## Ресурси

- [Різниця у функціональності](https://docs.aws.amazon.com/documentdb/latest/developerguide/functional-differences.html#functional-differences.array-indexing)
- [Різниця в API](https://docs.aws.amazon.com/documentdb/latest/developerguide/mongo-apis.html)
- [MongoDB 3.6 doc](https://www.docs4dev.com/docs/en/mongodb/v3.6/reference/core-query-plans.html)
- [Official MongoDB Doc - потрібно брати до уваги версію в якій з’явилася зміна про яку читаєте, зазвичай така інформація вказана в тексті](https://www.mongodb.com/docs/v4.2/reference/operator/aggregation/currentOp/)